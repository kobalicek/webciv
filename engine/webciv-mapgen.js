// [WebCiv]
// A Strategy Game Engine in JavaScript.
//
// [License]
// MIT - See LICENSE.md file in the package.
(function(core, $export, $as) {
"use strict";

const FAILED = core.FAILED;

const GameUtils = core.GameUtils;
const Random = core.Random;
const Brush = core.Brush;
const Sides = Brush.Sides;

const TerrainType = core.TerrainType;
const TerrainModifier = core.TerrainModifier;

const mapgen = Object.create(null);

// ============================================================================
// [mapgen.BaseMapGen]
// ============================================================================

/**
 * Base random map generator.
 *
 * This class implements everything except `generateContinents()`, which must
 * be reimplemented to provide different styles of continents. River placement
 * and various terrain generation is implemented here, but can be overridden as
 * well.
 */
class BaseMapGen {
  constructor(game, info) {
    this.game = game;
    this.map = game.map;

    this.random = new Random(info.seed);
    this.rivers = info.rivers || 0;
    this.landSize = Math.max(info.landSize || 0, 10);
    this.landMass = Math.max(info.landMass || 0, 100);
  }

  /**
   * Generates the whole map.
   */
  generate() {
    const map = this.map;
    map.supressNotifications++;

    this.generateContinents();
    this.generateRivers();
    this.generateTerrain();

    map.supressNotifications--;
    map.invalidateAll();
  }

  /**
   * Generates continents and islands.
   *
   * @abstract
   */
  generateContinents() {
    FAILED(`Abstract method called`);
  }

  /**
   * Generate rivers.
   */
  generateRivers() {
    const map = this.map;
    const continents = map.continents;

    const n = 2;
    const maxUnsuccessfulTries = 15;

    for (var continentId = 0; continentId < continents.length; continentId++) {
      const continent = continents[continentId];
      var numRivers = 0;
      var unsuccessful = 0;

      do {
        const r = this.random.irand(continent.size) * 2;
        const x = continent.coords[r + 0];
        const y = continent.coords[r + 1];

        const tile = map.getTile(x, y);
        if (tile.id !== TerrainType.Ocean && this.isIdealForRiverPlacement(x, y, n))
          numRivers += this.placeRiver(x, y);
        else
          unsuccessful++;
      } while (unsuccessful < maxUnsuccessfulTries);
    }
  }

  isIdealForRiverPlacement(x, y, n) {
    const map = this.map;

    var tile = map.getTile(x, y);
    if (tile.id === TerrainType.Ocean)
      return false;

    // Number of times we reached the end (`n` tiles not close to ocean or another river).
    var full = 0;

    // Check N tiles in all directions, all all are non-ocean then this is an
    // ideal place for placing a river. This algorithm just considers the land
    // that surrounds the tile, it doesn't do any smart heuristics.
    for (var i = 0; i < Sides.length; i++) {
      const dx = Sides[i].x;
      const dy = Sides[i].y;

      var ox = x;
      var oy = y;

      var px = map.normX(x + dx);
      var py = map.normY(y + dy);

      for (var j = 0; j < n; j++) {
        // Too close to the end of the map.
        if (ox === px && oy === py) return false;

        tile = map.getTileSafe(px, py);
        if (tile.id === TerrainType.Ocean || (tile.modifiers & TerrainModifier.kRiver) !== 0) {
          // Not an ideal place if it's right next to sea.
          if (j === 0) return false;
          break;
        }

        ox = px;
        oy = py;

        px = map.normX(px + dx);
        py = map.normY(py + dy);
      }

      full += Number(j === n);
    }

    // If at reached the end in at least two directions then it seems fine.
    // Otherwise we may generate a lot of false-positives especially on
    // maps with smaller islands, which should also have some possibility
    // to have rivers.
    return full >= 2;
  }

  placeRiver(x, y) {
    const map = this.map;
    const w = map.w;
    const h = map.h;

    var size = 1;
    var path = new Set();
    var dir = this.random.irand(4);

    for (;;) {
      const tile = map.getTile(x, y);

      // Check if we are near ocean and stop in such case.
      const top    = map.getTileSafe(x, y - 1);
      const left   = map.getTileSafe(x - 1, y);
      const bottom = map.getTileSafe(x, y + 1);
      const right  = map.getTileSafe(x + 1, y);

      if (top   .id === TerrainType.Ocean || left .id === TerrainType.Ocean ||
          bottom.id === TerrainType.Ocean || right.id === TerrainType.Ocean) {
        tile.modifiers |= TerrainModifier.kRiver;
        return size;
      }

      // Check if we are close to another river (not generated by us).
      if (((top   .modifiers & TerrainModifier.kRiver) !== 0 && !path.has(top   .y * w + top   .x)) ||
          ((left  .modifiers & TerrainModifier.kRiver) !== 0 && !path.has(left  .y * w + left  .x)) ||
          ((bottom.modifiers & TerrainModifier.kRiver) !== 0 && !path.has(bottom.y * w + bottom.x)) ||
          ((right .modifiers & TerrainModifier.kRiver) !== 0 && !path.has(right .y * w + right .x))) {
        tile.modifiers |= TerrainModifier.kRiver;
        return size;
      }

      // Move in random direction. However, if the move would terminate the
      // river (it's a tile near ocean) try to find some other tile instead.
      dir = (dir + this.random.irand(3) - 1) & 3;

      if (this.willTerminateRiver(x, y, Sides[dir].x, Sides[dir].y)) {
        const probability = size <  5 ? 1.00 :
                            size < 10 ? 0.80 :
                            size < 20 ? 0.50 : 0.2;
        if (this.random.drand() < probability) {
          for (var i = 0; i < Sides.length; i++) {
            const alt = (dir + i) & 3;
            if (!this.willTerminateRiver(x, y, Sides[alt].x, Sides[alt].y)) {
              dir = alt;
              break;
            }
          }
        }
      }

      path.add(y * w + x, true);

      if ((tile.modifiers & TerrainModifier.kRiver) === 0) {
        tile.modifiers |= TerrainModifier.kRiver;
        size++;
      }

      x = map.normX(x + Sides[dir].x);
      y = map.normY(y + Sides[dir].y);
    }
  }

  willTerminateRiver(rx, ry, dx, dy) {
    const map = this.map;

    const x = map.normX(rx, dx);
    const y = map.normY(ry, dy);

    if (x === rx && y === ry)
      return true;

    for (var i = 0; i < Sides.length; i++) {
      const px = x + Sides[i].x;
      const py = y + Sides[i].y;
      const tile = map.getTileSafe(px, py);

      if (tile.id === TerrainType.Ocean || (tile.modifiers & TerrainModifier.kRiver) !== 0)
        return true;
    }

    return false;
  }

  /**
   * Generate terrain.
   */
  generateTerrain() {
    const map = this.map;
    const w = map.w;
    const h = map.h;

    const mid = Math.floor(h / 2);

    for (var y = 0; y < h; y++) {
      const distanceFromPole = Math.min(y, h - 1 - y);
      const distanceFromMid  = Math.abs(y - mid);

      for (var x = 0; x < w; x++) {
        const tile = map.tiles[y * w + x];
        if (this.canChangeTerrain(tile)) {
          if (this.random.drand() < 0.2) {
            const r = this.random.drand();

            if (distanceFromPole < 8) {
              if (r < 0.4)
                this.placeTerrain(x, y, TerrainType.Arctic, this.random.irand(3) + 3);
            }
            else if (distanceFromMid < 6) {
              if (r < 0.7)
                this.placeTerrain(x, y, TerrainType.Desert, this.random.irand(9) + 2);
              else
                this.placeTerrain(x, y, TerrainType.Plains, this.random.irand(9) + 2);
            }
            else {
              if (r < 0.7)
                this.placeTerrain(x, y, TerrainType.Plains, this.random.irand(9) + 3);
              else
                this.placeTerrain(x, y, TerrainType.Jungle, this.random.irand(8) + 4);
            }
          }
        }
      }
    }
  }

  placeTerrain(x, y, id, numIterations) {
    const map = this.map;
    const w = map.w;
    const h = map.h;

    var i = 0;
    for (;;) {
      map.setTileId(x, y, id);
      if (++i >= numIterations) return;

      var dir = this.random.irand(4);
      for (var j = 0; j < 4; j++) {
        if (this.canChangeTerrain(map.getTileSafe(x + Sides[dir].x, y + Sides[dir].y)))
          break;
        dir = (dir + 1) & 3;
      }

      // Cannot place anything nearby.
      if (j === 4) return;

      x = map.normX(x + Sides[dir].x);
      y = map.normY(y + Sides[dir].y);
    }
  }

  canChangeTerrain(tile) {
    return tile.id === TerrainType.Grassland;
  }

  /**
   * Calculate a land mass - number of tiles that are not ocean.
   */
  calcLandMass() {
    const tiles = this.map.tiles;
    const len = tiles.length;

    const oceanType = TerrainType.Ocean;
    var mass = 0;

    for (var i = 0; i < len; i++)
      mass += Number(tiles[i].id !== oceanType);

    return mass;
  }

  /**
   * Calculate a maximum land mass
   */
  calcMassLimit() {
    const w = this.map.w;
    const h = this.map.h;

    // Maximum land mass is 70% for now.
    return Math.floor((Math.max(w - 2, 0) * Math.max(h - 2, 0)) * 0.70);
  }

  /**
   * Get random brush, see `draw()`.
   */
  getRandomBrush() {
    const i = this.random.irand(5);
    switch (i) {
      case  0: return Brush.Horz;
      case  1: return Brush.Vert;
      case  2: return Brush.Plus;
      case  3: return Brush.Diamond;
      default: return Brush.City;
    }
  }

  draw(cx, cy, brush, toTerrain, onTerrain) {
    const map = this.map;

    const w = map.w;
    const h = map.h;
    const tiles = map.tiles;

    var changes = 0;
    for (var i = 0; i < brush.length; i++) {
      const offset = brush[i];
      const dx = GameUtils.repeat(cx + offset.x, w);
      const dy = GameUtils.clamp(cy + offset.y, 0, h);

      const tile = tiles[dy * w + dx];
      if (tile.id === onTerrain) {
        map.setTileId(dx, dy, toTerrain);
        changes++;
      }
    }

    return changes;
  }
}
mapgen.BaseMapGen = BaseMapGen;

// ============================================================================
// [mapgen.SimpleMapGen]
// ============================================================================

/**
 * Simple random map generator implementation.
 */
class SimpleMapGen extends BaseMapGen {
  constructor(game, info) {
    super(game, info);
  }

  /** @overriden */
  generateContinents() {
    var massLimit = Math.min(this.landMass, this.calcMassLimit());
    var massCount = this.calcLandMass();

    while (massCount < massLimit) {
      const numIterations = this.random.irand(this.landSize) + 3;
      massCount += this.generateContinent(numIterations, this.getRandomBrush());
    }

    this.map.recalc();
  }

  /**
   * Generates a continent at some random position by using the specified
   * `brush` and `numIterations`.
   *
   * @param {number} numIterations Number of iterations the brush moves in
   *   random direction
   * @param {object[]} brush Brush to be used to fill the land, see `Brush`.
   *
   * @return {number} Number of ocean tiles changed to land.
   */
  generateContinent(numIterations, brush) {
    const w = this.map.w;
    const h = this.map.h;

    var minY = 4;
    var maxY = h - 4;

    if (minY >= maxY)
      FAILED(`Map '${w}x${h}' is too small`);

    var x = this.random.irand(w);
    var y = this.random.irand(maxY - minY) + minY;

    var changes = 0;
		do {
		  changes += this.draw(x, y, brush, TerrainType.Grassland, TerrainType.Ocean);

      switch (this.random.irand(4)) {
  			case  0: y--; break;
  			case  1: x++; break;
  			case  2: y++; break;
  			default: x--; break;
      }

      if (y < minY) y = minY;
      if (y > maxY) y = maxY;
		} while(--numIterations > 0);
		return changes;
  }
}
mapgen.SimpleMapGen = SimpleMapGen;

mapgen.generators = {
  simple: SimpleMapGen
};

$export[$as] = mapgen;

}).apply(null, typeof this.webciv === "object"
  ? [this.webciv, this.webciv, "mapgen"] : [require("./webciv-core"), module, "exports"]);
